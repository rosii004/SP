1.#include <iostream>
#include <cstring>

using namespace std;

void Transform(int br) {
    int nizaParni[100];
    int nizaNeparni [100];

    int temp=br;
    int counterParni=0;
    int counterNeparni=0;
    int sum=0;

    while(temp!=0) {
        int cifra=temp%10; //zeam posledna cifra
        //proveruvam dali e parna ili neparna
        if(cifra%2==0) {
            nizaParni[counterParni]=cifra; //na counter parni poso toa e indeksot
            counterParni++;
        }else {
            nizaNeparni[counterNeparni]=cifra;
            counterNeparni++;
        }
        sum+=cifra;
        temp/=10;  //ja brise poslednata cifra (zavrseno so cifrata)

    }
    //prvo for za parni

    for (int i = 0; i<counterParni ; i++) {
        cout<<nizaParni[i]<<" ";
    }
    cout<<endl;  //ke projde  ciklusot pa ke se pecati nov red zatoa tuka endl

    //for za neparni
    //-1 zada nema segmentation fault
    for (int i = counterNeparni-1; i >=0; i--) {
        cout<<nizaNeparni[i]<<" ";
    }
    cout<<endl;
    cout<<sum;
}

int main (){
    int n;
    cin>>n;


    Transform(n);



    return 0;
}

2.#include <iostream>
#include <iomanip> // за поубаво порамнување на печатење
#include <cmath>
using namespace std;

int main() {
    int m, n;
    cin >> m >> n;

    int matrica[100][100];

    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            cin >> matrica[i][j];
        }
    }

    int p, q;
    cin >> p >> q;

    int max_k = 0;

    // Најди го најголемиот можен ромб со центар (p, q)
    while (true) {
        bool valid = true;
        for (int i = -max_k; i <= max_k; i++) {
            int row = p + i;
            int col_left = q - (max_k - abs(i));
            int col_right = q + (max_k - abs(i));

            if (row < 0 || row >= m || col_left < 0 || col_right >= n) {
                valid = false;
                break;
            }
        }
        if (!valid) break;
        max_k++;
    }

    max_k--;


    // Печатење на ромб визуелно
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            // Проверуваме дали (i, j) припаѓа на ромбот
            int delta_row = abs(i - p);
            int max_col_offset = max_k - delta_row;
            if (delta_row <= max_k && abs(j - q) <= max_col_offset) {
                cout << setw(3) << matrica[i][j]; // порамни во 3 места
            } else {
                cout << "   "; // 3 празни места за да се совпаѓа
            }
        }
        cout << endl;
    }

    return 0;
}


3.
#include <iostream>
#include <cstring>

using namespace std;



int main (){

    char niza[100];
    scanf("%s", niza);  //vnesuvam nizata

    int n=strlen(niza);  

    for(int k=0;k<n;k++) {
        if(tolower(niza[k])=='s') { //ako malata verzija od bukvata e ednakva na taja s togas zameni ja
            niza[k]='$';
        } else if (tolower(niza[k])=='m') { //ako malata verzija od bukvata e ednakva na taja m togas zameni ja
            niza[k]='^';
            //ama za da bide kompletna zamenata site elmenti od nizata pomesti gi edno mesto na desno
                //so for pravam edno mesto plus
            for(int j=n+1;j>=k;j--) {  //od goleminata na nizata +1 poso pomestuvam edno mesto na desno,do momentalnata pozicija,koga pomestuvam na desno se namaluva nizata
                niza[j]=niza[j-1]; //j-1 poso pomestuvam na desno,-1 poso zemam mestoto na prethodnata pozicija
            }
            niza[k]='^';
        }
    }

    cout<<niza<<endl;
    return 0;
}
